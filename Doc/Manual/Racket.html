<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <title>Swig and Racket (FFI)</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>

<h1 id="swig-and-racket-ffi">Swig and Racket (FFI)</h1>

<p>Run the Racket Swig translator using the following command:</p>

<div class="shell"><pre>
swig -racket -extern-all <em>interface-file.i</em>
</pre></div>

<p>The output is a Racket module named <code><em>module.rkt</em></code>,
where <code><em>module</em></code> is the module name declared in the interface
file (or overridden by the <code>-module <em>module</em></code> command line
option).</p>

<p>The interface module must insert into the “rktheader” section a definition
of <code>foreign-lib</code> and <code>define-foreign</code>,
where <code>foreign-lib</code> is a variable whose value is the FFI library
reference and <code>define-foreign</code> is a definition form compatible with
those produced by <code>define-ffi-definer</code>. For example:</p>
  
<div class="code"><pre>
%insert(&quot;rktheader&quot;) %{
(define foreign-lib (ffi-lib &quot;libexample.so&quot;))
(define-ffi-definer define-foreign foreign-lib
  #:default-make-fail make-not-available)
%}
</pre></div>

<h2 id="translations">Translations</h2>

<h3 id="type-declarations">Type declarations</h3>

<p>The translations of type declarations are discussed in the “Types” section.</p>

<h3 id="constant-definitions">Constant definitions</h3>

<p>A <code>#define</code> constant is translated to a Racket variable
definition. If the translator cannot handle the right-hand side (for example, if
it is a nontrivial arithmetic expression), it emits a Racket expression that
calls a fictitious <code>FIXME</code> Racket function. For example:</p>

<div class="code"><pre>
#define ONE 1
#define TEN 0xA
#define ELEVEN (ONE + TEN)
#define FIFTY (4 * ELEVEN + 6)
</pre></div>
<div class="indent"><pre>=&gt;</pre></div>
<div class="targetlang"><pre>
(define ONE 1)
(define TEN #xA)
(define ELEVEN (+ 1 #xA)
(define FIFTY (FIXME #| 4*(1+0xA) +6 |#))
</pre></div>

<h3 id="variable-declarations">Variable declarations</h3>

<p>A variable is translated to a procedure similar to the result
of <code>make-c-parameter</code>. Calling the procedure with zero arguments
retrieves the variable’s current value, and calling it with one argument updates
the variable’s value. If the variable is declared immutable (for example, with
the <code>%immutable</code> directive), calling the procedure to set the
variable’s value raises an error.</p>

<p>A variable wrapper can also be customized by the <code>%rename</code>
directive and the “var-options” feature, which can contain
either <code>#:fail</code> or <code>#:make-fail</code> keyword arguments,
similar to those supported by the result of <code>define-ffi-definer</code>. For
example:</p>

<div class="code"><pre>
%feature(&quot;var-options&quot;) undef_var &quot;#:fail (lambda () #f)&quot;
// %feature(&quot;var-options&quot;) undef_var &quot;#:make-fail make-not-available&quot;
int undef_var;
</pre></div>

<p>If the foreign library does not contain <code>undef_var</code>, the
Racket <code>undef_var</code> variable will get the value <code>#f</code>
instead of a getter/setter procedure. If the commented-out feature is used
instead, then <code>undef_var</code> is bound to a procedure that always raises
an error when applied.</p>

<h3 id="function-declarations">Function declarations</h3>

<p>A function is translated to a procedure defined
using <code>define-foreign</code> and a <code>_fun</code> type. The formal
parameters are translated to <code>_fun</code> argument clauses; the default
translation produces a clause of the following shape for each parameter:</p>

<div class="targetlang"><pre>
[<em>argname</em> : <em>ffitype</em>]    // if the parameter name <em>argname</em> is given
<em>ffitype</em>                // if the parameter name is not given
</pre></div>

<p>The translation of parameters to clauses can be overridden with the “rktin”
typemap, which also allows multi-parameter mappings. The mapping must produce as
many argument clauses as there are parameters in the C declaration. For example,
here is a multi-parameter typemap that converts a single Racket argument (a
list) to a pair of length and array arguments to the foreign function:</p>

<div class="code"><pre>
%typemap(rktin) (int argc, char *argv[]) %{
  [$1_name : _int = (length $2_name)]
  [$2_name : (_list i _string)]
%}
</pre></div>

<p>A function wrapper can also be customized by the <code>%rename</code>
directive, the “fun-prefix” feature, the “fun-result” feature, and the
“fun-options” feature. The following is the general template of a function
wrapper:</p>

<div class="targetlang"><pre>
(define-foreign <em>rktname</em>
  (_fun <em>fun-prefix</em>
        <em>param-clause</em> ...
        -&gt; [result : <em>result-type</em>]
        -&gt; <em>result-expr</em>)
  #:c-id <em>cname</em>
  <em>fun-options</em>)
</pre></div>

<ul>

<li>The <code><em>result-expr</em></code> is determined as follows:
<ul>
  <li>If there is a “fun-result” declaration, its value is used.</li>

  <li>Otherwise, if there are any “rktargout” mappings,
  then <code><em>result-expr</em></code> is <code>(values
  result <em>argout-expr</em> ...)</code>, where
  each <code><em>argout-expr</em></code> comes from a “rktargout” mapping, in
  the order that the arguments appear. As a special case,
  if <code><em>result-type</em></code> is <code>_void</code>,
  then <code>result</code> is dropped from the result values.</li>

  <li>Otherwise, there is no <code><em>result-expr</em></code>. In that case,
  the <code>-&gt; <em>result-expr</em></code> line is omitted, and the <code>[result :
  <em>result-type</em>]</code> line is simplified to
  just <code><em>result-type</em></code>.</li>

</ul></li>

<li>The <code>#:c-id</code> declaration is omitted if there is no renaming.</li>

</ul>

<h2 id="types">Types</h2>

<p>The translation of C types to Racket FFI type descriptors uses the “rktffi”
typemap method, which maps a C type to a Racket expression that evaluates to an
FFI type descriptor (satisfying the <code>ctype?</code> predicate).</p>

<p>Types that have no mapping are handled specially by the translator. If the
translator cannot translate a type, it emits an expression that calls a
fictitious <code>_FIXME</code> function.</p>

<h3 id="builtin-typemap">Builtin typemap</h3>

<p>This section shows the built-in type mappings in Lib/racket/racket.swg:</p>

<div class="code"><pre>
/* Integer types */

%typemap(rktffi) char &quot;_byte&quot;;
%typemap(rktffi) signed char &quot;_byte&quot;;
%typemap(rktffi) unsigned char &quot;_ubyte&quot;;

%typemap(rktffi) wchar_t &quot;_wchar&quot;

%typemap(rktffi) short &quot;_short&quot;;
%typemap(rktffi) signed short &quot;_short&quot;;
%typemap(rktffi) unsigned short &quot;_ushort&quot;;

%typemap(rktffi) int &quot;_int&quot;;
%typemap(rktffi) signed int &quot;_int&quot;;
%typemap(rktffi) unsigned int &quot;_uint&quot;;

%typemap(rktffi) long &quot;_long&quot;;
%typemap(rktffi) signed long &quot;_long&quot;;
%typemap(rktffi) unsigned long &quot;_ulong&quot;;

%typemap(rktffi) long long &quot;_llong&quot;;
%typemap(rktffi) signed long long &quot;_llong&quot;;
%typemap(rktffi) unsigned long long &quot;_ullong&quot;;

%typemap(rktffi) intptr_t &quot;_intptr&quot;;
%typemap(rktffi) uintptr_t &quot;_uintptr&quot;;

%typemap(rktffi) int8_t &quot;_int8&quot;
%typemap(rktffi) uint8_t &quot;_uint8&quot;

%typemap(rktffi) int16_t &quot;_int16&quot;
%typemap(rktffi) uint16_t &quot;_uint16&quot;

%typemap(rktffi) int32_t &quot;_int32&quot;
%typemap(rktffi) uint32_t &quot;_uint32&quot;

%typemap(rktffi) int64_t &quot;_int64&quot;
%typemap(rktffi) uint64_t &quot;_uint64&quot;

%typemap(rktffi) size_t &quot;_size&quot;
%typemap(rktffi) ssize_t &quot;_ssize&quot;
%typemap(rktffi) ptrdiff_t &quot;_ptrdiff&quot;

/* Floating-point types */

%typemap(rktffi) float &quot;_float&quot;;
%typemap(rktffi) double &quot;_double&quot;;
%typemap(rktffi) long double &quot;_longdouble&quot;

/* Other atomic types */

%typemap(rktffi) bool &quot;_stdbool&quot;

%typemap(rktffi) void &quot;_void&quot;;

/* Pointer types */

%typemap(rktffi) void * &quot;_pointer&quot;;
%typemap(rktffi) char * &quot;_pointer&quot;;
%typemap(rktffi) unsigned char * &quot;_pointer&quot;;
</pre></div>

<p>The default FFI type for <code>double</code> accepts only Racket
floating-point numbers. To automatically coerce other number (such as exact
integers and rationals) to floating point, use <code>_double*</code> instead by
using the following declaration:</p>

<div class="code"><pre>
// Include in your interface module:
%typemap(rktffi) double &quot;_double*&quot;;
</pre></div>

<h3 id="struct-types">Struct types</h3>

<p>A C struct definition is translated to a Racket <code>define-cstruct</code> definition:</p>

<div class="code"><pre>
struct point_st { int x, y; }
</pre></div>
<div class="indent"><pre>=&gt;</pre></div>
<div class="targetlang"><pre>
(define-cstruct _point_st
  ([x _int]
   [y _int]))
</pre></div>

<p>The Racket definition defines three FFI types:</p>
<ul>

  <li><code>_point_st</code> is a FFI type for instances of the structure; it
  corresponds to <code>struct point_st</code></li>

  <li><code>_point_st-pointer</code> is an FFI type for non-nullable pointers to
  instances; it corresponds to <code>struct point_st *</code> but disallows
  NULL</li>

  <li><code>_point_st-pointer/null</code> is an FFI type for nullable pointers
  to instances; it corresponds to <code>struct point_st *</code> and allows NULL
    (represented by <code>#f</code>)</li>

</ul>

<p>Racket pointers carry tags, and <code>_point_st-pointer/null</code> requires
a pointer argument to have the corresponding tag (<code>point_st-tag</code>,
which has the value <code>'point_st</code>). See the Racket FFI documentation
for details.</p>

<p>The translator records known struct names; this information is used by the
translation of pointer types (see the “Pointer types” section), and it is
propagated by typedefs (see the “Typedefs” section).</p>

<h3 id="typedefs">Typedefs</h3>

<p>The handling of a typedef depends on whether the right-hand side is a known
struct type or not.</p>

<p>A typedef to a known struct type is handled as follows:</p>

<div class="code"><pre>
typedef struct point_st Point;
</pre></div>
<div class="indent"><pre>=&gt;</pre></div>
<div class="targetlang"><pre>
(define _Point              _point_st)
(define _Point-pointer      _point_st-pointer)
(define _Point-pointer/null _pointer_st-pointer/null)
</pre></div>

<p>In addition, the typedef name is recorded as a known struct type.</p>

<p>If the typedef occurs strictly before the declaration of the struct type, the
resulting Racket module will contain variable references before their
definitions. This can be fixed manually by moving the struct-generated
definition before the typedef-generated definitions.</p>

<p>A typedef to an anonymous struct declaration is handled as if the typedef
name replaced the struct name:</p>

<div class="code"><pre>
typedef struct { int x, y, z; } Point3d;
</pre></div>
<div class="indent"><pre>=&gt;</pre></div>
<div class="targetlang"><pre>
(define-cstruct _Point3d ([x _int] [y _int] [z _int]))
</pre></div>

<p>If the target of a typedef is not a known struct type, then the translation
does not include pointer types:</p>

<div class="code"><pre>
typedef int errcode;
</pre></div>
<div class="indent"><pre>=&gt;</pre></div>
<div class="targetlang"><pre>
(define _errcode _int)
</pre></div>

<h3 id="union-types">Union types</h3>

<p>A C union declaration is translated to a Racket definition
using <code>_union</code>:</p>

<div class="code"><pre>
union shape_t { rectangle_t rect ; circle_t circ; };
</pre></div>
<div class="indent"><pre>=&gt;</pre></div>
<div class="targetlang"><pre>
(define _shape_t (_union _rectangle_t _circle_t))
</pre></div>

<h3 id="enumeration-types">Enumeration types</h3>

<p>A C enumeration declaration is translated to a Racket definition
using <code>_enum</code>:</p>

<div class="code"><pre>
enum direction_t { north, east, south, west, up = 100 };
</pre></div>
<div class="indent"><pre>=&gt;</pre></div>
<div class="targetlang"><pre>
(define _direction_t (_enum &#39;(north east south west up = 100)))
</pre></div>

<h3 id="pointer-types">Pointer types</h3>

<p>The translation of a C pointer type depends on the target type.</p>

<p>If the target type is typemapped to a Racket FFI type for a known struct type
(or typedef to a known struct type), then the associated nullable pointer type
is produced.</p>

<p>If the target type is a known struct type (or typedef to a known struct
type), then the associated nullable pointer type is produced.</p>

<div class="code"><pre>
struct point_st *   =&gt;  _point_st-pointer/null
Point *             =&gt;  _Point-pointer/null
</pre></div>

<p>If the target type is a function type, then the translation of the function
type is produced.</p>

<p>Otherwise, an expression of the form <code>(_pointer-to target-type)</code>
is produced, where <code>target-type</code> is the translation of the target
type. Note, however, that <code>_pointer-to</code> is a constant function that
always produces <code>_pointer</code>; the <code>target-type</code> is included
to aid manual editing of the resulting code.</p>

<div class="code"><pre>
int *               =&gt;  (_pointer-to _int)  =  _pointer
</pre></div>

<p>Qualifiers like <code>const</code> are discarded. The generated Racket code
does not respect mutation restrictions based on <code>const</code>.</p>

<h2 id="supported-and-unsupported-swig-features">Supported and unsupported Swig features</h2>

<p>This section lists various Swig features and indicates whether the Swig
module for Racket supports them, and if not, whether it provides alternative
methods for achieving the same goals.</p>

<h3 id="default-arguments-5.4.8-13.5">Default arguments (5.4.8, 13.5)</h3>

<p>Default arguments are not directly supported. That is, the following
declaration syntax is not supported:</p>

<div class="code"><pre>
int plot(double x, double y, int color=WHITE);  // NOT SUPPORTED
</pre></div>

<p>Also, the “default” typemap method is not supported. (See the “Common typemap
method” section below.)</p>

<p>To create a wrapper with default arguments, use the “fun-prefix” feature to
specify the formal parameter list (ending in <code>::</code>) for
the <code>_fun</code> syntax:</p>

<div class="code"><pre>
%feature(&quot;fun-prefix&quot;) plot &quot;(x y [color 0]) ::&quot;
int plot (double x, double y, int color);
</pre></div>
<div class="indent"><pre>=&gt;</pre></div>
<div class="targetlang"><pre>
(define-foreign plot
  (_fun (x y [color 0]) ::
        [x : _double]
        [y : _double]
        [flags : _int]
        -&gt; int))
</pre></div>

<h3 id="constant-functions-callback-nocallback-5.4.9"><code>%constant</code>
functions, <code>%callback</code>, <code>%nocallback</code> (5.4.9)</h3>

<p>The Racket FFI is able to convert between C function pointers and Racket
procedures, so Swig's callback support is not usually necessary. On the other
hand, a C function converted into a Racket procedure and then back into a C
function has overhead on every call, and in some cases it requires cooperation
with the GC to avoid premature collection. So it can be convenient to have a
reference to the C function as a simple <code>_fpointer</code>. (The types of
functions accepting the callbacks should also be overridden to
be <code>_fpointer</code>.)</p>

<div class="code"><pre>
%callback("%s_cb");
int add(int, int);
%nocallback;
%constant int sub(int, int);
</pre></div>
<div class="indent"><pre>=&gt;</pre></div>
<div class="targetlang"><pre>
(define-foreign add_cb _fpointer #:c-id add)
(define-foreign add (_fun _int _int -> _int))
(define-foreign sub _fpointer #:c-id sub)
</pre></div>

<h3 id="code-insertion-5.6">Code insertion (5.6)</h3>

<p>The standard <code>"begin"</code>, <code>"runtime"</code>, <code>"header"</code>,
<code>"wrapper"</code>, and <code>"init"</code> targets are not used.</p>

<p>Use <code>"rktbegin"</code>, <code>"rktheader"</code>, <code>"rktwrapper"</code>, <code>"rktinit"</code>
instead.</p>

<ul>

<li><code>rktbegin</code>: before the <code>#lang racket/base</code> line</li>

<li><code>rktheader</code>: before the wrappers; define <code>foreign-lib</code>
and <code>define-foreign</code> here</li>

<li><code>rktwrapper</code>: wrappers are generated here</li>

<li><code>rktinit</code>: extra code after all the wrappers are defined, emitted
at module top-level (that is, not within a function)</li>

</ul>

<p>Use only the <code>"..."</code> and <code>%{...%}</code> notations for inserted code. Do not use <code>{...}</code>.</p>

<p>Do not use <code>%inline</code>, since it emits code to the <code>"header"</code> target.</p>

<h3 id="input-output-and-inputoutput-parameters-12.1.2-12.1.3-12.1.4">Input, output, and input/output parameters (12.1.2, 12.1.3, 12.1.4)</h3>

<p>For a function with out (or inout) parameters, an idiomatic wrapper would use
the special <code>_ptr</code> function parameter syntax (not an FFI type), as
follows:</p>

<div class="code"><pre>
void f(int *outparam);
</pre></div>
<div class="indent"><pre>=&gt;</pre></div>
<div class="targetlang"><pre>
(define-foreign f
  (_fun [outparam : (_ptr o _int)]
        -&gt; _void
        -&gt; outparam))
</pre></div>

<p>But by default, the translator produces the following Racket wrapper:</p>

<div class="targetlang"><pre>
(define-foreign f
  (_fun [outparam : (_pointer-to _int)]
        -&gt; _void))
</pre></div>

<p>The argument can be treated as an out-parameter by using the “rktin” typemap
to override the default parameter clause to use the <code>(_ptr o ___)</code>
argument syntax:</p>

<div class="code"><pre>
%typemap(rktin) int *outparam %{
  [outparam : (_ptr o _int)]
%}
</pre></div>

<p>And the result of the wrapper can be set using the “fun-result” feature:</p>

<div class="code"><pre>
%feature(&quot;fun-result&quot;) f &quot;outparam&quot;;
</pre></div>

<p>As an alternative, the argument can be automatically added to the function
result values by using the “argout” typemap. In this example, that would
cause <code>f</code> to return two values, the first of which is
always <code>(void)</code>, so it makes more sense to use the “fun-result”
feature to replace the result expression entirely.</p>

<div class="code"><pre>
%typemap(&quot;rktargout&quot;) int *outparam &quot;outparam&quot;;
// %typemap(&quot;rktargout&quot;) int *outparam &quot;$1_name&quot;;  // alternative
</pre></div>

<p>Parameters that are used for both input and output should use the <code>(_ptr
io _)</code> function parameter syntax instead. Likewise, parameters that are
only used for input should use the <code>(_ptr i _)</code> function syntax.</p>

<h3 id="typemap-special-variables-13.4.3">Typemap special variables (13.4.3)</h3>

<p>The special variables are handled by Swig, so they are supported.</p>

<p>The <code>$typemap(method, typepattern)</code> macro is supported, but beware
that the Racket translator only uses typemaps for certain builtin base
types.</p>

<h3 id="common-typemap-methods-13.5">Common typemap methods (13.5)</h3>

<p>The common typemap methods (“in”, “out”, etc) are not supported.</p>

<p>The common “in” method has two Racket analogues:</p>

<ul>

<li>“rktin” maps parameters to <code>_fun</code> parameter clauses</li>

<li>“rktffi” maps parameter types to Racket FFI types (for parameters where
“rktin” did not match)</li>

</ul>

<p>The common “argout” method has the Racket analogue “rktargout”. It maps
parameters to Racket expressions to be included in the result values.</p>

<p>The common “out” method has the Racket analogue “rktffi”.</p>

<p>The “default” typemap has no direct Racket analogue. See the “Default
arguments” section above.</p>

<p>The “check” method has no direct Racket analogue. Use a custom FFI type
(see <code>make-ctype</code>), use a wrapper (use the “fun-options” feature to
give a <code>#:wrap</code> argument to <code>_fun</code>), or perform the check
at a higher level before calling the wrapper function. Here is an example using
a custom FFI type:</p>

<div class="code"><pre>
%insert(&quot;rktheader&quot;) %{
(define _pos-int
  (make-ctype _int
              (lambda (v) (if (&gt; v 0) v (error &#39;_pos-int &quot;not positive: ~e&quot; v)))))
%}
%typemap(ffitype) int positive &quot;_pos-int&quot;;
int isqrt(int positive);
</pre></div>
<div class="indent"><pre>=&gt;</pre></div>
<div class="targetlang"><pre>
(define _pos-int
  (make-ctype _int
              (lambda (v) (if (&gt; v 0) v (error &#39;_pos-int &quot;not positive: ~e&quot; v)))))
...
(define-foreign bar
  (_fun [positive : _pos-int]
        -&gt; _int))
</pre></div>

<p>To reject NULL pointers in arguments, where the target type is a structure
type, change the “rktffi” mapping of the parameter to use
the <code>_structname-pointer</code> type instead of the
default <code>_structname-pointer/null</code> type.</p>

<p>The following typemap methods have no Racket analogue: “typecheck”,
“arginit”, “freearg”, “newfree”, “ret”, “memberin”, “varin”, “varout”, and
“throws”.</p>

<h3 id="multi-argument-typemaps-13.9">Multi-argument typemaps (13.9)</h3>

<p>The “rktin” method supports multi-argument type mappings. The mapping must
produce as many argument clauses as there are parameters in the C
declaration. For example, here is a multi-parameter typemap that converts a
single Racket argument (a list) to a pair of length and array arguments to the
foreign function:</p>

<div class="code"><pre>
%typemap(rktin) (int argc, char *argv[]) %{
  [$1_name : _int = (length $2_name)]
  [$2_name : (_list i _string)]
%}
</pre></div>

<h3 id="object-ownership-newobject-delobject-14.2">Object ownership, <code>%newobject</code>, <code>%delobject</code> (14.2)</h3>

<p>The <code>%newobject</code> and <code>%delobject</code> directives are not
supported. Use the “fun-options” feature and
Racket’s <code>ffi/unsafe/alloc</code> library instead. For example:</p>

<div class="code"><pre>
%feature(&quot;fun-options&quot;) blah &quot;#:wrap (allocator free)&quot;
Foo *blah() { return new Foo(); }
</pre></div>

<p>This will cause Racket to call the Racket <code>free</code> function on the
allocated object when the Racket cpointer wrapping it is garbage-collected. The
the documentation for <code>ffi/unsafe/alloc</code> for more information.</p>

<h3 id="contracts-contract-15">Contracts, <code>%contract</code> (15)</h3>

<p>Contracts are not supported at the FFI wrapper level. FIXME</p>

<h3 id="arithmetic-expressions">Arithmetic expressions</h3>

<p>Arithmetic expressions can occur in <code>#define</code> right-hand sides and
array bounds. The Racket translator only handles trivial expressions; it
generates a call to the fictitious <code>FIXME</code> function for non-trivial
expressions that must be fixed by hand.</p>

<h3 id="other-unsupported-features">Other unsupported features</h3>

<ul>

<li><code>%extend</code> (5.5.6)</li>

<li>nested structures (5.5.7)</li>

<li>C++ (6, 7, 8, 9)</li>

<li>constraints, the <code>constraints.i</code> library (12.2)</li>

<li>temporary/local variables introduced by typemaps (13)</li>

<li>typemap fragments, <code>%fragment</code> (13.11)</li>

<li>the run-time type checker (13.12)</li>

<li>typemaps and overloading (13.13) (FIXME)</li>

<li><code>%exception</code> (14.1)</li>

<li>variable-length arguments, <code>%varargs</code> (16)</li>

</ul>

</body>
</html>
